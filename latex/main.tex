\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[automake]{glossaries}
\usepackage{array}
\usepackage[table]{xcolor}

\usepackage[
  backend=biber,
  style=authoryear, % or numeric, ieee, apa, ...
]{biblatex}

\usepackage{hyperref}

\addbibresource{references.bib}

\makeglossaries

\newglossaryentry{api}
{
    name=API, 
    description={API stands for \emph{Application Programming Interface}. It describes the public interface of a module or service, often exposed over a network}
}

\newglossaryentry{rest}
{
    name=REST,
    description={REST stands for \emph{Representational State Transfer}. It is an architectural style for distributed hypermedia systems}
}

\newglossaryentry{http}
{
    name=HTTP,
    description={HTTP stands for \emph{Hypertext Transfer Protocol}. It is a protocol used in internet communication and was defined in RFC 2616 \parencite{rfc2616}}
}

\newglossaryentry{adm}
{
    name={Anemic Domain Model},
    description={The objects describing the domain only hold data, no logic}
}

\newglossaryentry{rdm}
{
    name={Rich Domain Model},
    description={Objects incorporate both data and the behavior or rules that govern that data}
}

\newacronym{www}{WWW}{World Wide Web}

\newacronym{hateoas}{HATEOAS}{Hypermedia as the engine of application state}

\newacronym{html}{HTML}{HyperText Markup Language}

\newacronym{json}{JSON}{JavaScript Object Notation}

\newacronym{xml}{XML}{Extensible Markup Language}

\newacronym{dao}{DAO}{Data Access Object}

\newacronym{ddd}{DDD}{Domain Driven Design}

\begin{document}

\title{How does an Event Sourcing architecture compare to CRUD systems with an independent audit log, when it comes to scalability, performance and traceability?}
\author{Lukas Karsch}

\begin{titlepage}
    \centering

    \includegraphics[width=0.3\textwidth]{images/HdM_Logo.svg.png}
    \vspace{1cm}

    {\large Bachelor's Thesis in Computer Science and Media}

    \vspace{1.5cm}

    % Title
    {\LARGE\bfseries How does an Event Sourcing architecture compare to CRUD systems with an independent audit log, when it comes to scalability, performance and traceability?}

    \vspace{0.5cm}
    \rule{\linewidth}{0.5pt}
    \vspace{0.5cm}

    {\large\bfseries Lukas Karsch}

    \vspace{0.3cm}

    45259

    \vspace{0.8cm}

    %LTeX: language=de-DE
    {\bfseries Hochschule der Medien Stuttgart}
    %LTeX: language=en-US

    \vspace{0.8cm}

    Submitted on 2026/03/02

    \vspace{0.3cm}

    to obtain the degree of Bachelor of Science

    \vfill

    \begin{flushleft}
        \begin{tabular}{ll}
            \textbf{Main Supervisor:}      & Prof. Dr. Tobias Jordine \\[0.3cm]
            \textbf{Secondary Supervisor:} & Felix Messner            \\[0.3cm]
        \end{tabular}
    \end{flushleft}

\end{titlepage}

\newpage

%LTeX: language=de-DE
\section*{Ehrenwörtliche Erklärung}
%LTeX: language=en-US

\newpage

\tableofcontents

\newpage

\section{Introduction}

here i use \gls{api}

\subsection{Motivation}

\subsection{Research question(s)}

\subsection{Goals and non goals}

\subsection{Structure of the paper}

\section{Basics}

\subsection{WWW, Web APIs, REST}

The \acrfull{www} is a connected information network used to exchange data. Resources are can be accessed via URIs which are transferred using formats like JSON or HTML via protocols like \gls{http}. HTTP is a stateless protocol based on a request-response structure. It supports standardized request types (e.g. GET and POST) which convey a semantic meaning \parencite{jacobs_architecture_2004}.

Web APIs are interfaces which enable applications to communicate. They use HTTP as network-based API \parencite[138]{fielding_architectural_2000}. Modern APIs typically follow \gls{rest} principles. REST stands for "Representational State Transfer" and describes an architectural style for distributed hypermedia systems \parencite[76]{fielding_architectural_2000}.

REST APIs follow principles derived from a set of constraints (e.g. imposed by the HTTP protocol). One of them is "stateless communication": Communication between clients and the server must be \emph{stateless}, meaning the client has to attach all necessary information for the server to fully understand the request.

Further, in REST applications, every resource must be addressable via a unique ID, which can then be used to derive URIs to access the resource. Below are some examples for resources and URIs which could be derived from them:

\begin{itemize}
    \item Book; ID=1; URI=\texttt{http://example.com/books/1}
    \item Book; ID=2; URI=\texttt{http://example.com/books/2}
    \item Author; ID=100; URI=\texttt{http://example.com/authors/100}
\end{itemize}

The "\acrfull{hateoas}" principle describes that resources should be linked to each other. Clients should be able to control the application by following a series of links provided by the server \parencite{tilkov_brief_2007}.

Every resource must support the same interface, typically that of HTTP methods (GET, POST, PUT, etc.) where operations on the resource are mapped to one method of the interface. A POST operation on a customer might map to the \texttt{createCustomer()} operation on a service.

Resources are decoupled from their representations. Client can request different representations of a resource, depending on their needs \parencite{tilkov_brief_2007}: a web browser might request \acrshort{html}, while another server or application might request \acrshort{xml} or \acrshort{json}.

%s TODO explain CRUD! 

\subsection{Layered Architecture Foundations}
\label{sec:layered}

Layered Architecture is the most common architecture pattern in enterprise applications. Applications following a layered architecture are divided into \emph{horizontal layers}, with each layer performing a specific role. A standard implementation consists of the following layers:

\begin{itemize}
    \item Presentation: Handles requests and displays data in a user interface or by turning it into representations (e.g. JSON)
    \item Business: Encapsulates business logic
    \item Persistence: Persists data by interacting with the underlying persistence technologies (e.g. SQL databases)
    \item Database
\end{itemize}

A key concept in this design is layers of isolation, where layers are "closed", meaning a request must pass through the layer directly below it to reach the next, ensuring that changes in one layer do not affect others.

In a layered application, data flows downwards during request handling and upwards during the response: a request arrives in the presentation layer, which delegates to the business layer. The business layer fetches data from the persistence layer which holds logic to retrieve data, e.g. by encapsulating SQL statements.

The database responds with raw data, which is turned into a \acrlong{dao} by the persistence layer. The business layer uses this data to execute rules and make decisions. The result will be returned to the presentation layer which can then wrap the response and return it to the caller. \parencite{richards_software_2015}

The data in layered applications is often times modeled in an \emph{anemic} way. In an \gls{adm}, business entities are treated as only data. They are objects which contain no business logic, only getters and setters. Business logic is entirely contained in the business (or "service") layer. \textcite{anemic-fowler-2003} describes this as an object-oriented \emph{antipattern}.

% TODO figure

\subsection{Domain Driven Design}
\label{sec:ddd}

\acrfull{ddd} is a different architectural approach for applications.  It differs from layered architecture primarily in the way the domain is modelled and the responsibilities of application services.

The core idea of \acrshort{ddd} is that the primary focus of a software project should not be the underlying technologies, but the domain. The domain is the topic with which a software concerns itself. The software design should be based on a model that closely matches the domain and reflects a deep understanding of business requirements. \parencite[8, 12]{evans_domain-driven_2004}

This domain model is built from a \emph{ubiquitous language} which is a language shared between domain experts and software experts. This ubiquitous language is built directly from the domain model and must be used in all communications regarding the software. \parencite[24-26]{evans_domain-driven_2004}

%s TODO here, talk about model driven design -> way from the language to the code 

The software must always reflect the way that the domain is talked about. Changes to the domain and the ubiquitous language must result in an immediate change to the domain model.

When modeling the domain model, the aim should not be to create a perfect replica of the real world. While it should carefully be chosen, the domain model artificial and forms a selective abstraction which should be chosen for its utility. \parencite[12, 13]{evans_domain-driven_2004}

While \hyperref[sec:layered]{Layered Architecture} organizes code into technical tiers and is typically built on anemic domain models, often resulting in the \emph{big ball of mud} antipattern \parencite[V]{richards_software_2015}, \acrshort{ddd} demands a \gls{rdm} where objects incorporate both data and the behavior or rules that govern that data. The code is structured semantically into bounded context and modules which are chosen to tell the "story" of a system rather than its technicalities. \parencite[80]{evans_domain-driven_2004}

%s todo entities and value objects. 
Entities (also known as reference objects) are domain elements fundamentally defined by a thread of continuity and identity rather than their specific attributes. Entities must be distinguishable from other entities, even if they share the same characteristics. To ensure consistency and identity, a unique identifier is assigned to entities. This identifier is immutable throughout the object's life. \parencite[65-69]{evans_domain-driven_2004}

Value Objects are elements that describe the nature or state of something and have no conceptual identity of their own. They are interesting only for their characteristics. While two entities with the same characteristics are considered as different from each other, the system does not care about "identity" of a value object, since only its characteristics are relevant. Value objects should be used to encapsulate concepts, such as using an "Address" object instead of distinct "Street" and "City" attributes. Value objects should be immutable. They are never modified, instead they are replaced entirely when a new value is required. \parencite[70-72]{evans_domain-driven_2004}

Using a \gls{rdm} does not mean that there should be no layers, the opposite is the case. \textcite{evans_domain-driven_2004} advocates for using layers in domain driven designs. He proposes the following layers: \parencite[53]{evans_domain-driven_2004}

\begin{itemize}
    \item Presentation: Presents information and handles commands
    \item Application Layer: Coordinates app activity. Does not hold business logic, but delegate tasks and hold information about their progress
    \item Domain Layer: Holds information about the domain. Stateful objects (rich domain model) that hold business logic and rules
    \item Infrastructure layer: Supports other layers. Handles concerns like communication and persistence
\end{itemize}

\textcite[75]{evans_domain-driven_2004} points out that in some cases, operations in the domain can not be mapped to one object. For example, transferring money does conceptually not belong to one bank account. In those cases, where operations are important domain concepts, domain services can be introduced as part of model-driven design. To keep the domain model rich and not fall back into procedural style programming like with \gls{adm}, it is important to use services only when necessary. Services are not allowed to strip the entities and value objects in the domain of behavior. According to Evans, a good domain service has the following characteristics:

\begin{itemize}
    \item The operation relates to a domain concept which would be misplaced on an entity or a value object
    \item The operation performed refers to other objects in the domain
    \item The operation is stateless
\end{itemize}

\subsection{Traceability and auditing in IT systems}

\subsubsection{Why is traceability a business requirement}

\subsubsection{Audit Logs}

\subsubsection{Event Streams}

\subsubsection{Rebuilding state from an audit log and an event stream}

\subsection{Event Sourcing and event-driven architectures}

\subsection{(Eventual) Consistency}

\subsection{Scalability of systems}

\section{Related Work}

\section{Proposed Method}

\subsection{Project requirements}

\subsection{Performance}

\subsection{Scalability or flexibility (TODO)}

\subsection{Traceability}

\subsection{Tech Stack}

\section{Implementation}

\subsection{CRUD implementation}

\subsection{ES/CQRS implementation}

\subsection{Infrastructure}

\section{Results}

\section{Discussion}

\subsection{Analysis of results}

\subsection{Conclusion \& Further work}

Finally, I'm done.

\printglossaries

\printbibliography

\end{document} % This is the end of the document
