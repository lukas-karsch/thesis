\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[automake]{glossaries}
\usepackage{array}
\usepackage[table]{xcolor}

\usepackage[
  backend=biber,
  style=authoryear, % or numeric, ieee, apa, ...
]{biblatex}
\DefineBibliographyStrings{english}{
  and = {\&}
}

\usepackage{hyperref}

\addbibresource{references.bib}

\makeglossaries

\newglossaryentry{api}
{
    name=API, 
    description={API stands for \emph{Application Programming Interface}. It describes the public interface of a module or service, often exposed over a network}
}

\newglossaryentry{rest}
{
    name=REST,
    description={REST stands for \emph{Representational State Transfer}. It is an architectural style for distributed hypermedia systems}
}

\newglossaryentry{http}
{
    name=HTTP,
    description={HTTP stands for \emph{Hypertext Transfer Protocol}. It is a protocol used in internet communication and was defined in RFC 2616 \parencite{rfc2616}}
}

\newglossaryentry{adm}
{
    name={Anemic Domain Model},
    description={The objects describing the domain only hold data, no logic}
}

\newglossaryentry{rdm}
{
    name={Rich Domain Model},
    description={Objects incorporate both data and the behavior or rules that govern that data}
}

\newglossaryentry{atomicity}
{
    name=Atomicity,
    description={Atomicity means that an action is either fully executed or not at all. Atomic operations make sure the application is not left in an invalid state \parencite[10]{bernstein_principles_2009}}
}

\newacronym{www}{WWW}{World Wide Web}

\newacronym{hateoas}{HATEOAS}{Hypermedia as the engine of application state}

\newacronym{html}{HTML}{HyperText Markup Language}

\newacronym{json}{JSON}{JavaScript Object Notation}

\newacronym{xml}{XML}{Extensible Markup Language}

\newacronym{dao}{DAO}{Data Access Object}

\newacronym{ddd}{DDD}{Domain Driven Design}

\newacronym[plural=URIs]{uri}{URI}{Uniform Resource Identifier}

\newacronym{crud}{CRUD}{Create Read Update Delete}

\newacronym{dto}{DTO}{Data Transfer Object}

\newacronym{acid}{ACID}{Atomicity, Consistency, Isolation, Durability}

\newacronym{cqrs}{CQRS}{Command Query Responsibility Segregation}

\newacronym{cqs}{CQS}{Command And Query Separation}

\newacronym{base}{BASE}{Basically Available, Soft State, Eventual Consistency}

\begin{document}

\title{How does an Event Sourcing architecture compare to CRUD systems with an independent audit log, when it comes to scalability, performance and traceability?}
\author{Lukas Karsch}

\begin{titlepage}
    \centering

    \includegraphics[width=0.3\textwidth]{images/HdM_Logo.svg.png}
    \vspace{1cm}

    {\large Bachelor's Thesis in Computer Science and Media}

    \vspace{1.5cm}

    % Title
    {\LARGE\bfseries How does an Event Sourcing architecture compare to CRUD systems with an independent audit log, when it comes to scalability, performance and traceability?}

    \vspace{0.5cm}
    \rule{\linewidth}{0.5pt}
    \vspace{0.5cm}

    {\large\bfseries Lukas Karsch}

    \vspace{0.3cm}

    45259

    \vspace{0.8cm}

    %LTeX: language=de-DE
    {\bfseries Hochschule der Medien Stuttgart}
    %LTeX: language=en-US

    \vspace{0.8cm}

    Submitted on 2026/03/02

    \vspace{0.3cm}

    to obtain the degree of Bachelor of Science

    \vfill

    \begin{flushleft}
        \begin{tabular}{ll}
            \textbf{Main Supervisor:}      & Prof. Dr. Tobias Jordine \\[0.3cm]
            \textbf{Secondary Supervisor:} & Felix Messner            \\[0.3cm]
        \end{tabular}
    \end{flushleft}

\end{titlepage}

\newpage

%LTeX: language=de-DE
\section*{Ehrenwörtliche Erklärung}
%LTeX: language=en-US

\newpage

\tableofcontents

\newpage

\section{Introduction}

here i use \gls{api}

\subsection{Motivation}

\subsection{Research question(s)}

\subsection{Goals and non goals}

\subsection{Structure of the paper}

\section{Basics}

\subsection{WWW, Web APIs, REST}

The \acrfull{www} is a connected information network used to exchange data. Resources are can be accessed via \glspl{uri} which are transferred using formats like JSON or HTML via protocols like \gls{http}. HTTP is a stateless protocol based on a request-response structure. It supports standardized request types, such as \texttt{GET} and \texttt{POST}, which convey a semantic meaning \parencite{jacobs_architecture_2004}.

Web APIs are interfaces that enable applications to communicate. They use HTTP as a network-based API \parencite[138]{fielding_architectural_2000}. Modern APIs typically follow \gls{rest} principles. REST stands for "Representational State Transfer" and describes an architectural style for distributed hypermedia systems \parencite[76]{fielding_architectural_2000}.

REST APIs adhere to principles derived from a set of constraints imposed by the HTTP protocol, for example. One such constraint is "stateless communication": Communication between clients and the server must be \emph{stateless}, meaning the client must provide all the necessary information for the server to fully understand the request.

Furthermore, every resource in REST applications must be addressable via a unique ID, which can then be used to derive a \acrshort{uri} to access the resource. Below are some examples for resources and \glspl{uri} which could be derived from them:

\begin{itemize}
    \item Book; ID=1; URI=\texttt{http://example.com/books/1}
    \item Book; ID=2; URI=\texttt{http://example.com/books/2}
    \item Author; ID=100; URI=\texttt{http://example.com/authors/100}
\end{itemize}

The "\acrfull{hateoas}" principle states that resources should be linked to each other. Clients should be able to control the application by following a series of links provided by the server \parencite{tilkov_brief_2007}.

Every resource must support the same interface, usually HTTP methods (GET, POST, PUT, etc.) where operations on the resource correspond to one method of the interface. For example, a POST operation on a customer might map to the \texttt{createCustomer()} operation on a service.

Resources are decoupled from their representations. Clients can request different representations of a resource, depending on their needs \parencite{tilkov_brief_2007}: a web browser might request \acrshort{html}, while another server or application might request \acrshort{xml} or \acrshort{json}.

%s TODO explain CRUD! here or somewhere else? 

\subsection{Layered Architecture Foundations}
\label{sec:layered}

Layered Architecture is the most common architecture pattern in enterprise applications. Applications following a layered architecture are divided into \emph{horizontal layers}, with each layer performing a specific role. A standard implementation consists of the following layers:

\begin{itemize}
    \item Presentation: Handles requests and displays data in a user interface or by turning it into representations (e.g. JSON)
    \item Business: Encapsulates business logic
    \item Persistence: Persists data by interacting with the underlying persistence technologies (e.g. SQL databases)
    \item Database
\end{itemize}

A key concept in this design is layers of isolation, where layers are "closed", meaning a request must pass through the layer directly below it to reach the next, ensuring that changes in one layer do not affect others.

In a layered application, data flows downwards during request handling and upwards during the response: a request arrives in the presentation layer, which delegates to the business layer. The business layer fetches data from the persistence layer which holds logic to retrieve data, e.g. by encapsulating SQL statements.

The database responds with raw data, which is turned into a \acrlong{dao} by the persistence layer. The business layer uses this data to execute rules and make decisions. The result will be returned to the presentation layer which can then wrap the response and return it to the caller. \parencite{richards_software_2015}

The data in layered applications is often times modeled in an \emph{anemic} way. In an \gls{adm}, business entities are treated as only data. They are objects which contain no business logic, only getters and setters. Business logic is entirely contained in the business (or "service") layer. \textcite{anemic-fowler-2003} describes this as an object-oriented \emph{antipattern}.

% TODO figure

\subsection{Domain Driven Design}
\label{sec:ddd}

\acrfull{ddd} is a different architectural approach for applications.  It differs from layered architecture primarily in the way the domain is modelled and the responsibilities of application services.

The core idea of \acrshort{ddd} is that the primary focus of a software project should not be the underlying technologies, but the domain. The domain is the topic with which a software concerns itself. The software design should be based on a model that closely matches the domain and reflects a deep understanding of business requirements. \parencite[8, 12]{evans_domain-driven_2004}

This domain model is built from a \emph{ubiquitous language} which is a language shared between domain experts and software experts. This ubiquitous language is built directly from the real domain and must be used in all communications regarding the software. \parencite[24-26]{evans_domain-driven_2004}

%s TODO here, talk about model driven design -> way from the language to the code 

The software must always reflect the way that the domain is talked about. Changes to the domain and the ubiquitous language must result in an immediate change to the domain model.

When modeling the domain model, the aim should not be to create a perfect replica of the real world. While it should carefully be chosen, the domain model artificial and forms a selective abstraction which should be chosen for its utility. \parencite[12, 13]{evans_domain-driven_2004}

While \hyperref[sec:layered]{Layered Architecture} organizes code into technical tiers and is typically built on anemic domain models, often resulting in the \emph{big ball of mud} antipattern \parencite[V]{richards_software_2015}, \acrshort{ddd} demands a \gls{rdm} where objects incorporate both data and the behavior or rules that govern that data. The code is structured semantically into bounded context and modules which are chosen to tell the "story" of a system rather than its technicalities. \parencite[80]{evans_domain-driven_2004}

%s todo entities and value objects. 
Entities (also known as reference objects) are domain elements fundamentally defined by a thread of continuity and identity rather than their specific attributes. Entities must be distinguishable from other entities, even if they share the same characteristics. To ensure consistency and identity, a unique identifier is assigned to entities. This identifier is immutable throughout the object's life. \parencite[65-69]{evans_domain-driven_2004}

Value Objects are elements that describe the nature or state of something and have no conceptual identity of their own. They are interesting only for their characteristics. While two entities with the same characteristics are considered as different from each other, the system does not care about "identity" of a value object, since only its characteristics are relevant. Value objects should be used to encapsulate concepts, such as using an "Address" object instead of distinct "Street" and "City" attributes. Value objects should be immutable. They are never modified, instead they are replaced entirely when a new value is required. \parencite[70-72]{evans_domain-driven_2004}

Using a \gls{rdm} does not mean that there should be no layers, the opposite is the case. \textcite{evans_domain-driven_2004} advocates for using layers in domain driven designs. He proposes the following layers: \parencite[53]{evans_domain-driven_2004}

\begin{itemize}
    \item Presentation: Presents information and handles commands
    \item Application Layer: Coordinates app activity. Does not hold business logic, but delegate tasks and hold information about their progress
    \item Domain Layer: Holds information about the domain. Stateful objects (rich domain model) that hold business logic and rules
    \item Infrastructure layer: Supports other layers. Handles concerns like communication and persistence
\end{itemize}

\textcite[75]{evans_domain-driven_2004} points out that in some cases, operations in the domain can not be mapped to one object. For example, transferring money does conceptually not belong to one bank account. In those cases, where operations are important domain concepts, domain services can be introduced as part of model-driven design. To keep the domain model rich and not fall back into procedural style programming like with \gls{adm}, it is important to use services only when necessary. Services are not allowed to strip the entities and value objects in the domain of behavior. According to Evans, a good domain service has the following characteristics:

\begin{itemize}
    \item The operation relates to a domain concept which would be misplaced on an entity or a value object
    \item The operation performed refers to other objects in the domain
    \item The operation is stateless
\end{itemize}

\subsection{Event Sourcing and event-driven architectures}

\subsection{CRUD architecture}

% TODO refine 

\hyperref[sec:layered]{Layered architectures} are the standard for data-oriented enterprise applications. These applications mostly follow a \acrshort{crud} architecture. \acrshort{crud} is an acronym coined by \textcite{martin_managing_1983} that stands for "Create, Read, Update, Delete". These four actions can be applied to any record of data.

The state of domain objects in a \acrshort{crud} architecture is often mapped to normalized tables on a relational database, though other storage mechanisms maybe used. The application acts on the current state of the data, with all actions (reads and writes) acting on the same data. % TODO cite 

\acrshort{acid} (\acrlong{acid}) are an important feature of CRUD applications. They can be guaranteed using transactions, ensuring that data stays consistent and operations are \glslink{atomicity}{atomic}. \parencite[10,11]{bernstein_principles_2009}

\subsection{CQRS Architecture}

\acrfull{cqrs} is an architectural pattern based on the fundamental idea that the models used to update information should be separate from the models used to read information. This approach originated as an extension of Bertrand Meyer’s \acrfull{cqs} principle, which states that a method should either perform an action (a command) or return data (a query), but never both. \parencite[148]{meyer_standard_2006}

\acrshort{cqrs} is different from \acrshort{cqs} in the fact that in \acrshort{cqrs} objects are split into two objects, one containing commands, one containing queries. \parencite[17]{young_cqrs_2010}

\acrshort{cqrs} applications are typically structured by splitting the application into two paths:

\begin{itemize}
    \item Command Side: Deals with data changes and captures user intent. Commands tell the system \emph{what} needs to be done rather than overwriting previous state. Commands are validated by the system before execution and can be rejected. \parencite[11,12]{young_cqrs_2010}
    \item Read Side: Strictly for reading data. The read side is not allowed to modify anything in the data store. The read side typically stores \glspl{dto} that can directly be returned to the presentation layer. \parencite[20]{young_cqrs_2010}
\end{itemize}

In a CQRS architecture, the read side typically updates its data asynchronously by consuming notifications or events generated by the write side. Because the models for updating and reading information are strictly separated, a synchronization mechanism is required to ensure the read store eventually reflects the changes made by commands. This usually leads to stale data on the read side.

Each read service independently updates its model by consuming notifications or events published by the write side, allowing the read model to store optimized, denormalized views on the data. \parencite[23]{young_cqrs_2010}

%s TODO figure 

\subsection{(Eventual) Consistency}

% TODO have to talk about "read your writes"? 
% TODO maybe move above CRUD and CQRS 

\textcite{gray_dangers_1996} explain that large-scale systems become unstable if they are held consistent at all times according to \acrshort{acid} principles. The reasons are deadlocks and the large amount of communication necessary to handle atomic transactions in distributed systems. To address these issues, modern distributed systems often adopt the \acrshort{base} (\acrlong{base}) model which explicitly trades off isolation and strong consistency for availability. Eventually consistent systems are allowed to exist in a so-called "soft state" which eventually converges through the use of synchronization mechanisms over time rather than being strongly consistent at all times. \parencite{braun_tackling_2021, vogels_eventually_2009} This creates an inconsistency window in which data is not consistent across the system. During this window, stale data may be read. \parencite{vogels_eventually_2009}

\subsection{Traceability and auditing in IT systems}

\subsubsection{Why is traceability a business requirement}

\subsubsection{Audit Logs}

\subsubsection{Event Streams}

\subsubsection{Rebuilding state from an audit log and an event stream}

\subsection{Scalability of systems}

\section{Related Work}

\section{Proposed Method}

\subsection{Project requirements}

\subsection{Performance}

\subsection{Scalability or flexibility (TODO)}

\subsection{Traceability}

\subsection{Tech Stack}

\section{Implementation}

\subsection{CRUD implementation}

\subsection{ES/CQRS implementation}

\subsection{Infrastructure}

\section{Results}

\section{Discussion}

\subsection{Analysis of results}

\subsection{Conclusion \& Further work}

Finally, I'm done.

\printglossaries

\printbibliography

\end{document} % This is the end of the document
