% !TeX root = ../main.tex
\chapter{Requirement Analysis}
\label{ch:requirement-analysis}

This thesis aims to provide a fair, quantitative comparison of \acrshort{crud} and \acrshort{cqrs}-\acrshort{es} architectures regarding all three research questions. To achieve this, the architectures should be applied not only to the same domain, but to the exact same requirements.

\section{Functional Requirements}
\label{sec:functional-requirements}

A functional requirement describes a specific behavior that a product must exhibit under specific circumstances. These requirements specify what the system \emph{does} by detailing the capabilities and functions the solution must possess to allow users to perform their tasks~\cite[4]{wiegers_software_2023}. To ensure clarity regarding exactly how the system should behave, functional requirements are often written using patterns that include the keyword "shall," such as "The system shall let the user do something"~\cite[109]{wiegers_software_2023}.

\subsection{Project Description}
\label{sec:project-description}

The applications will implement a course enrollment and grading system which might for example be used in universities. Professors can create courses and lectures which students can enroll to. These lectures can have assignments, which professors enter grades for. Once a lecture is finished, final grades and awarded credits can be calculated. Students are able to view their enrollments, grades and credits.

\subsection{Entities}
\label{sec:entities}

Two types of users exist in the domain: professors and students. Their personal information is not relevant for this thesis, which is why only their first and last name are stored for presentation reasons. The student additionally has a semester.

Professors can create courses. Courses have a name, a description, an amount of credits they yield, a minimum amount of credits required to enroll and can have a set of courses as prerequisites.

Courses are the "blueprints" for lectures. Lectures are the "implementation" of a course for a semester. Each lecture created from a course yields the course's amount of credits and has the requirements specified by the course. Lectures have a lifecycle: they can be in draft state, open for enrollment, in progress, finished or archived. A lecture has a list of time slots and a maximum amount of students that can enroll.

A lecture can have several assessments. Each assessment has a type. The professor can enter grades for a student and an assessment. Grades are integers in the range of 0 to 100. Credits are awarded to a student as soon as they completed all assessments for a lecture with a passing grade (grade higher than 50) and once a lecture's status is set to finished.

\subsection{Business Rules and System Constraints}
\label{sec:business-rules}

Relationships and business rules in this system are deliberately chosen complex, involving many relationships between \hyperref[sec:entities]{entities} and intricate validation rules. This approach was adopted in order to be able to make realistic assumptions about the research question by evaluating a project that closely resembles complex, real-world scenarios.

Based on the domain described in \autoref{sec:project-description}, the following list presents a selection of constraints and rules which are central to the system. As this thesis focuses on an architectural comparison, not every functional requirement going into the application is listed explicitly.

\begin{itemize}
    \item Referential Integrity: The system shall verify the existence of all referenced entities during request handling. Requests involving non-existent entities shall be rejected.
    \item The system shall prevent conflicts such as time slot overlaps.
    \item When a student tries enrolling to a lecture which is already full, they shall be put on a waitlist.
    \item When a student disenrolls from a lecture, the next eligible student (higher semesters are preferred) shall be enrolled.
    \item Actions on a lecture shall only be performed during the appropriate lifecycle state. For example, enrolling shall only be possible during a lifecycle of "open for enrollment". Grades shall only be assigned when the lecture is "finished".
\end{itemize}

\section{Non-functional Requirements}
\label{sec:non-functional-requirements}

A non-functional requirement, often referred to as a \emph{quality attribute}, describes the quality or performance characteristics of a solution~\cite[4]{wiegers_software_2023}. Rather than defining \emph{what} the product does, these requirements focus on \emph{how well it functions}. They establish specific goals or constraints for the design and implementation, such as targets for security, availability, or response time, to ensure the system satisfies user expectations~\cite[67]{wiegers_software_2023}.

The following non-functional requirements (quality attributes) are defined.

\subsection{Service Level Objectives}
\label{sec:slo}

While \glspl{sla} are agreements with users regarding uptime and performance, \glspl{slo} are the technical targets used by engineers to meet those requirements~\cite[63,65]{beyer_site_2016}. This thesis attempts to define realistic \acrshortpl{slo} to establish a "breaking point" for each architecture.

Following \textcite[135]{nielsen_usability_1993}, a response time of 100ms is the threshold for human perception of "instant" feedback. This serves as the baseline for the following targets:

\begin{enumerate}[label={SLO \arabic*}, ref={SLO \arabic*}, leftmargin=*]
    \item \textbf{Latency \gls{slo}}: All endpoints shall maintain a client-side P95 latency of $\le$100ms to ensure the system feels "instant" for 95\% of requests. \label{slo-latency}
    \item \textbf{Freshness \gls{slo}}: In the Event Sourcing implementation, the asynchronous nature of projections introduces a lag. All writes shall be reflected in the read-model within $\le$100ms to ensure eventual consistency remains imperceptible. While the read-side is eventually consistent, the command-side (write-model) shall maintain immediate consistency to ensure business rules are validated against the latest state. \label{slo-freshness}
    \item \textbf{Reliability \gls{slo}}: Both implementations shall maintain a failure rate of <0.1\% under stress. \label{slo-reliability}
\end{enumerate}

\subsection{Auditing}
\label{sec:req-auditing}

Both systems need to be fully auditable. Every change to an entity must be reflected as a historical record. Historic states should be accurately reconstructible.

\subsection{Observability}
\label{sec:req-observability}

The systems must expose observability endpoints. These should be able to present information about the system internals. Precisely, CPU and threadpool usage, database connections and size of data stores should be available. Additionally, response times should be exposed as histograms.

\subsection{Consistency}
\label{sec:req-consistency}

To ensure the integrity of the operations, the following consistency requirements apply:

\begin{itemize}
    \item \textbf{Write Consistency}: Both architectures shall provide immediate (strong) consistency for write operations. This ensures that any command (e.g., enrolling a student) is validated not only against the individual Aggregate's / entity's state, but also against set-based invariants and global constraints. This prevents violations of business rules that span multiple entities or require a global view of the system state.
    \item \textbf{Read Consistency}: The \acrshort{crud} implementation shall provide immediate consistency for reads. The \acrshort{es}-\acrshort{cqrs} implementation may use eventual consistency for its read-models according to the \hyperref[slo-freshness]{Freshness SLO}.
\end{itemize}

\subsection{Contract}
\label{sec:contract}

Both implementations must follow the same contract regarding endpoints, request and response schemas and state transitions. To ensure this, an extensive test suite shall be set up. While the internals of the implementations will be vastly different architecturally, they will both have the same public \gls{api}, making it possible to send requests and verify the responses. Therefore, one test suite shall be developed which can be executed on both applications. The test suite should include integration tests for all \gls{api} endpoints covering both regular and edge-case (error) scenarios to ensure that both implementations behave identically.
