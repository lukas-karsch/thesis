I need to create the public interface of my API. 

To recap, below are the use cases from my expos√© ([[Expose Lukas Karsch Bachelorarbeit_02.pdf]])

1. **EnrollmentCommand**  
    During course registration week, hundreds of students enroll in and drop courses while instructors update grades.  
    **Goal**: Measure performance of concurrent writes on the same entity and read-heavy loads like listing all students in a course
2. **SumAllCreditsQuery**  
   Sum up all credits a student has accumulated from their finished courses  
    **Goal**: Compare time to query a StudentCredits projection vs. the time it takes to JOIN the tables and SUM the credits in the CRUD implementation.
3. **ShowHistoricalGradesQueryShow** 
   all grade changes for student #123 in Mathematics between April 1 and June 1, including who made the change and what the grade was at each point in time. **Goal:** Measure the time required to reconstruct the historical state and the business intent (who, why) from the Audit Log versus the time required to replay the event stream.

Let's think about which endpoints this would translate to:

| endpoint                    | query parameters                           | returns                                                                       |
| --------------------------- | ------------------------------------------ | ----------------------------------------------------------------------------- |
| `POST` /lectures/enroll     | studentId                                  | 201, `{success: true}`                                                        |
| `GET` /stats/credits        | studentId                                  | 200, sum of all credits that the student accumulated through finished courses |
| `GET` /stats/grades/history | student_id, lecture_id, startDate, endDate | 200, list of all states of the grade throughout the time period.              |
## Entities 
Of course, we need entities. Let's try to keep those as simple as possible.

**Student:**
- id 
- firstName
- lastName 
- lectures 

**Professor** 
- id 
- firstName
- lastName 
- lectures 

**Course** 
- id 
- name 
- professor
- description
- credits (= ECTS)

**Lecture** 
- id 
- course_id 
- maximumStudents 
- dates 

**Grade**
- grade 
- given_at 
- lecture 

Important distinction between course and lecture! A lecture has actual dates and is the "implementation" of a course that is the generic description 
## Rest of the endpoints 

| endpoint                     | query parameters                | returns                                              |
| ---------------------------- | ------------------------------- | ---------------------------------------------------- |
| `GET` /courses               |                                 | 200, list of all courses                             |
| `POST` /courses              |                                 | 201, create a new course                             |
| `POST` /courses/course_id    | professor_id                    | 201, create a lecture from the course                |
| `GET` /lectures              | student_id                      | 200, list of all lectures the student is enrolled in |
| `GET` /lectures/lecture_id   |                                 | 200 return the lecture & enrolled students           |
| `POST` /lectures/lecture_id  | student_id, professor_id, grade | 201, assign a grade to the student                   |
| `PATCH` /lectures/lecture_id | student_id, professor_id, grad  | 200, update a grade                                  |
| `GET` /stats/grades          | student_id                      | 200, list of all grades the student has              |
im sure there are some missing, but i will add those in future log entries.
[[API Design]] always contains the current definition of my endpoints

## Enforcing the design
How can I make sure that these endpoints are implemented by both applications? 
### Interface
```java
package karsch.lukas.enrollment;
  
@RequestMapping("/enrollment")  
public interface IEnrollmentController {  
  
    @PostMapping  
    @ResponseStatus(HttpStatus.CREATED)  
    ResponseEntity<CourseDto> enrollToCourse(String courseId);  
}
```

Putting Spring annotations on interfaces is supported! Then, both applications can just implement all controllers and are forced to adhere to the interface. What I don't like here is how the request mappings and response status are not easily visible to the implementations, but I will live with that. 
https://www.baeldung.com/spring-interface-driven-controllers
