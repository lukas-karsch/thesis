To ensure clean communication, **all** endpoints will use DTOs. This forces me to use a mapper and never accidentally return sensitive fields from the backend. 
## Request Payload
Input validation using [[Springboot Validation]] is always important! Request objects are mapped to `record` classes
that should be annotated using the validation annotations.
## Error or Success responses 

Commands do not return data - this is a [[CQRS (Command Query Responsibility Segregation)]] principle, but I will
enforce it in both implementations so that they have an identical interface. #cqrs

To still return _something_, I must think about the way I return errors and success. 

I'm thinking of creating a generic ApiResponse< T> class that will be returned from every endpoint. It could look like this: 

```typescript
{
	"status": "success" | "error",
	"code": number,
	"message": string
	"data": T
}
```

Always combine this with appropriate status codes and I should be good. When replying to commands, `data` can be null.

-> Implementation in `ApiResponse.java`
### Error Responses

- Define custom `RuntimeException` subclasses
- Derive the status code from those 
- `@ControllerAdvice` global exception handler with `@ExceptionHandler` methods 
- **`ProblemDetail`** class from Spring https://www.baeldung.com/spring-boot-return-errors-problemdetail
## Today 
Now, I will start to implement the DTOs.
## Traceability

#traceability
I am once again thinking about the problem of traceability. In my exposÃ©, I said:

> For instance, an UPDATE on a balance field could represent a "Refund," a "Fee Charged," or a "Manual Correction." This
> lack of context makes historical analysis and debugging significantly harder

This is correct, but I have to figure out how to demonstrate this problem in my domain of grading / enrollment.
### Brainstorming
- different reasons a grade was updated?
    - assign grade initially
    - update grade manually
    - correction of grading scale (batch update by prof)
- marking a lecture as "failed"
    - student un-enrolled
    - student was kicked out by prof
    - student failed the exam (due to bad grade) -> automatic fail
- student disenrolled
    - clicked "disenroll"
    - professor kicked out
    - professor updated max number of participants and the remainder was kicked out by the system

These could be kept track of using a separate "reason" column in the CRUD system, while the ES implementation inherently
keeps track of all these events.

-> i probably need to start documenting the system requirements explicitly! 