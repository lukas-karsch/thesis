#audit-log 
In classic CRUD systems where traceability is a requirement, audit logs are implemented.

The audit log in my CRUD project should have the following shape: 
```java
record AuditLogEntry<T>(
	String entity, 
	String action, // "CREATE", "UPDATE", "DELETE"
	T oldValue,
	T newValue, 
	Date modifiedAt, 
	Long modifiedByUserId
 ) {}
```
> Based on "Audit Log" by Martin Fowler and "Design - Build - Run" by Dave Ingram

Looks good to have a type parameter on here, but it might be unnecessary complexity, especially because I need to write the audit log into a database - so the objects will have to be serialized anyways. **The audit log should probably just contain a JSON string**, or I add logic to automatically serialize it when saving. 
## Implementing the Audit Log 
There are several ways to implement this. Small overview: 
- **1 Explicitly write an audit log entry on every change** 
	- simplistic 
	- no hidden logic 
	- error-prone (forgetting to log when implementing new logic)
- **2 Use Spring logic (TODO add info)**
	- e.g. `@Aspect` by Spring #aop
	- using `@EntityListener` on entities (https://chatgpt.com/c/68f7830d-6d40-832c-9078-ad4560a33863); `@PostLoad` can save a snapshot on a base entity that would look like this: 
	  ```java
	  @MappedSuperclass
	  @EntityListeners(MyEntityListener.class) 
	  abstract class AuditableEntity{
		  @Transient @Data private String snapshotJson;
	  }
	  ```
	- allows capturing the application level user 
- **3 Use database triggers**
	- ensures that _all_ changes are logged, even when they bypass business logic 
	- can not capture the application user - would require each table to include a modifiedBy column 
### Decision 
**Final decision on option 2.**
- allows capturing the application user 
- simple implementation 
- `AuditLogEntry` is a simple entity class controlled by JPA that I can query in whichever way I would like (-> observability, traceability)
- I do not use database triggers or stored procedures, so changes will always pass through application code 